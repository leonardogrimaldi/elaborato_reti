\documentclass[a4paper,12pt]{report}
\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{color}
\usepackage{minted}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\usepackage[italian]{cleveref}
\title{Relazione del progetto di Programmazione di Reti 
    \\ Traccia 3: Monitoraggio di Rete}

\author{Leonardo Grimaldi}
\date{\today}   
\begin{document}
\maketitle
We have now added a title, author and date to our first \LaTeX{} document!
\section{Consegna}
Realizzare uno script Python per monitorare lo stato di una rete, controllando la disponibilità di uno o più host tramite il protocollo ICMP (ping).
%
Lo script deve consentire all'utente di specificare gli indirizzi IP degli host da monitorare e deve visualizzare lo stato (online/offline) di ciascun host.
\section{Funzionamento}
All'avvio dello script \texttt{client.py} verrà chiesto all'utente di inserire in console l'hostname (es. \texttt{google.com}) oppure l'indirizzo IP (es. \texttt{8.8.8.8}) della macchina della quale si vuole sapere la disponibilità.
%
Qualora arrivi la risposta del destinatario, si otterrà un messaggio del formato: \texttt{17 byte da 216.58.204.238: icmp\_seq=0 ttl=111 tempo=16 ms}, dove il numero di byte è dato dalla dimensione della sezione DATA (nel nostro caso \mintinline{python3}|DATA = "Buongiorno mondo!"|) e il tempo indica il delay, ovvero quanto ci ha messo a ricevere la risposta dal tempo di invio.
%
Nel caso in cui non si riceva una risposta, a schermo verrà solamente stampato quanti byte sono stati inviati, oppure in casi eccezionali un messaggio di errore.
%
Per terminare correttamente lo script su \texttt{Windows} bisogna utilizzare la combinazione di tasti \texttt{CTRL + Break}.
\section{Codice}
Il sorgente è composto da tre sezioni principali necessarie per l'implementazione base del \texttt{ping}, che andrò ad elencare e spiegare in dettaglio.
\subsection*{\texttt{ICMPchecksum(packet)}}
Il codice scritto in questo metodo contiene la logica di calcolo di un checksum ICMP.
%
Prende in input un oggetto \texttt{bytes()} e restituisce in output un \texttt{int} con soli 16 bit meno significativi utili.
%
\begin{minted}[linenos]{python3}
  def ICMPchecksum(packet):
  temp = packet
  if len(temp) % 2 != 0:
      temp += bytes([0])
\end{minted}
Il pacchetto viene spostato in una variabile di appoggio \texttt{temp} per evitare di modificare il parametro in input e causare inconsistenze nel codice.
%
\\ Successivamente viene eseguito un controllo sulla parità: nel caso in cui il numero di byte del pacchetto è dispari, viene aggiunto alla fine un byte \texttt{x00} di padding.
\begin{minted}[linenos, firstnumber=last]{python3}
  first = int.from_bytes(temp[0:2], byteorder='big')
  sum = first
  for i in range(2, len(temp) - 1, 2):
      next = int.from_bytes(temp[i:i+2],byteorder='big')
      sum += next
\end{minted}
In questa porzione di codice vengono presi 2 byte e convertiti in \texttt{int} e sommati con i due successivi finché non si raggiunge la fine.
\begin{minted}[linenos, firstnumber=last]{python3}
  overflow = sum >> 16
  checksum = ~(sum + overflow) & 0xFFFF
  return checksum
\end{minted}
Si identifica l'\texttt{overflow} prendendo i 16 bit più significativi e lo si aggiunge a \texttt{sum}. Si effettua il complemento a 1 di tale valore con il carattere \texttt{~} e poi si azzerano i primi 16 bit (ridondanti dato che il checksum è a 16 bit mentre l'intero a 32).
%
\\ Notare che \textbf{il metodo \texttt{ICMPchecksum} non azzera in alcun modo il campo `checksum' di un pacchetto}, sarà infatti compito del chiamante farlo.
\subsection*{\texttt{ping(mySocket, destinationHost,\\ identifier, sequenceNumber)}}
Viene usato per effettuare un messaggio di Echo request a un destinatario.
Riceve in input:
\begin{itemize} 
  \item \texttt{mySocket}: oggetto socket da usare per l'invio del pacchetto
  \item \texttt{destinationHost}: indirizzo IP oppure host name del destinatario
  \item \texttt{identifier}: identificatore del pacchetto da inviare
  \item \texttt{sequenceNumber}: numero di sequenza del pacchetto
\end{itemize}
\begin{minted}[linenos, breaklines, breakbytoken]{python3}
  def ping(mySocket, destinationHost, identifier, sequenceNumber):
  checksum = 0
  header = struct.pack('!BBHHH', TYPE_ECHO_REQUEST, CODE_ECHO_REQUEST, checksum, identifier, sequenceNumber)
  # len(data) Ci dà il numero di caratteri nella stringa
  # struct.pack('!10s', ...) dice quindi di usare 10 byte
  # encode() uses UTF-8 encoding by default. 
  data = struct.pack('!' + str(len(DATA)) + 's', DATA.encode())
  packet = header + data
\end{minted}
Prima di inviare il pacchetto lo dobbiamo costruire: teniamo il valore di checksum a 0 e usiamo la funzione \texttt{struct.pack()} per convertire le variabili di Python in oggetti \texttt{bytes()} che sarà successivamente più facile 
\end{document}